# -*- coding: utf8 -*-
import sys

def getSize(x, lev=0):
    size = sys.getsizeof(x)
    print('\t' * lev, f'Тип данных:{type(x)}, Размер:{size} байт, Значение переменной:{x}')
    if hasattr(x, '__iter__'):
        if hasattr(x, 'items'):
            for key, value in x.items():
                getSize(key, lev + 1)
                size += sys.getsizeof(key)
                getSize(value, lev + 1)
                size += sys.getsizeof(value)
        elif not isinstance(x, str):
            for item in x:
                getSize(item, lev + 1)
                size += sys.getsizeof(item)
    return f"Суммарный размер {x} : {size} байт"

#Задание №1
# Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков.
# Проанализировать результат и определить программы с наиболее эффективным использованием памяти.
# Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько вариантов кода для одной и той же задачи.
# Результаты анализа вставьте в виде комментариев к коду. Также укажите в комментариях версию Python и разрядность вашей ОС.
def liter(n): #функция по-русски склоняющая слово "число"
    if 10 < n%100 < 15:
        return f"чисел"
    elif n%10 == 1:
        return f"число"
    elif n%10 in [2,3,4]:
        return f"числa"
    elif n%10 in [0,5,6,7,8,9]:
        return f"чисел"


sum_size = 0
temp =[]
count = 0
for i in range(2,10):
    sum_size += sys.getsizeof(i)
    for j in range(2,100):
        sum_size += sys.getsizeof(j)
        if j%i == 0:
            count +=1
    temp.append([i,count])
    sum_size += sys.getsizeof(count)
    sum_size += sys.getsizeof(temp)
    count = 0
for i in range(len(temp)):
    print(f'Числу {temp[i][0]} кратны {temp[i][1]} {liter(temp[i][1])} из ряда от 2 до 99')
    sum_size += sys.getsizeof(liter(temp[i][1]))
print(f'Суммарный размер переменных {sum_size} байт')
print()
print()
# На удивление много информации (12000 байт)для такой простенькой программы.
# хотя чего удивляться - там около 1000 чисел обрабатывается
# Ввел в цикл for j in range диапазон (32768,1000000), комп задумался надолго ))
# Если в цикле for i in range(2,10) увеличить верхнюю границу например до 1000,
# то вполне можно и не дождаться выдачи результата, лично я не дождался. ))
# Полагаю, что сложность алгоритма тут ~ O(n*m)



#Задание №2
# Во втором массиве сохранить индексы четных элементов первого массива.
# Например, если дан массив со значениями 8, 3, 15, 6, 4, 2, то во второй
# массив надо заполнить значениями 1, 4, 5, 6 (или 0, 3, 4, 5 - если индексация начинается с нуля),
# т.к. именно в этих позициях первого массива стоят четные числа.
from random import randint, seed
seed(1)
temp = [randint(32,60000) for _ in range(20)]
print(getSize(temp))
tamp = []
for i in range(len(temp)):
    if temp[i]%2 == 0:
        tamp.append(i)
# print('Чётные числа находятся на:')
print(getSize(tamp))
# for i in tamp:
    # print(f'{i+1}-ой позиции списка {temp}')

#Здесь имеется линейная зависимость количества затрачиваемой памяти от количества элементов списка и их размера(разрядности)
# Ступенчатый рост количества занимаемой памяти наблюдается при величинах чисел в списке temp больше 32768
# Полагаю, что сложность алгоритма O(N)



#Задание №7
# Напишите программу, доказывающую или проверяющую, что для множества натуральных чисел
# выполняется равенство: 1+2+...+n = n(n+1)/2, где n - любое натуральное число.
def bar(n):
    if n == 0:
        return 0
    return getSize(n) + getSize(bar(n - 1))
n = int(input('Введите число '))
# print(f'Равенство: 1+2+...+n = n(n+1)/2, доказано: {bar(n)} = {round(n*(n+1)/2)}')
print(bar(n))
# Памяти потребляет довольно много 11510 байт при количестве итераций 100, по объему используемой памяти сродни заданию №1
# сложность алгоритма О(n2)